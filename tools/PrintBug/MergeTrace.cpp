#include "SlimmerTools.h"

// #define SLIMMER_PRINT_BLOCKS

// Recording the basic block stack.
// The last executed instruction is
// the CurIndex-th instruction of basic block BBID.
struct StackInfo {
  // ID of the current and the last executed basic block
  int32_t BBID, LastBBID;
  // The index of the next instruction
  // i.e., the next instruction is BB2Ins[BBID][CurIndex]
  uint32_t CurIndex;
  StackInfo() {}
  StackInfo(int32_t bb_id, int32_t last_bb_id, int64_t cur_index)
      : BBID(bb_id), LastBBID(last_bb_id), CurIndex(cur_index) {}
};

/// This function takes the trace generated by LLVM and PIN
/// and generated a list of SmallestBlocks that contain
/// all the information needed for analyzing.
///
/// \param inst_file - path to Inst file generated by SlimmerTrace pass.
/// \param trace_file_name - path to trace file generated by the instrumented
/// application.
/// \param output_file_name - path to output file.
/// \param impactful_fun_call - recorded the function calls that impact the
/// outside enviroment.
///
void MergeTrace(char *trace_file_name, set<uint64_t> &impactful_fun_call,
                vector<SmallestBlock> &block_trace) {
  block_trace.clear();

  char event_label;
  const uint64_t *tid_ptr, *length_ptr, *addr_ptr, *addr2_ptr;
  const uint32_t *id_ptr;

  // fun_counter[<Thread ID tid, Function Address fun>]
  //    = how many times that thread tid has executed function fun.
  map<pair<uint64_t, uint64_t>, uint32_t> fun_counter;

  map<uint64_t, set<uint64_t> > args;
  map<uint64_t, vector<StackInfo> > call_stack;
  // Recording whether this is the first basic block
  map<uint64_t, pair<uint8_t, uint32_t> > is_first;

  TraceIter iter(trace_file_name);
  while (iter.NextEvent(event_label, tid_ptr, id_ptr, addr_ptr, length_ptr,
                        addr2_ptr)) {

#ifdef SLIMMER_PRINT_BLOCKS
    switch (event_label) {
      case BasicBlockEventLabel:
        printf("BasicBlockEvent:  %lu\t%u\n", *tid_ptr, *id_ptr);
        break;
      case MemoryEventLabel:
        printf("MemoryEvent:      %lu\t%u\t%p\t%lu\n", *tid_ptr, *id_ptr,
    (void*)*addr_ptr, *length_ptr);
        break;
      case ReturnEventLabel:
        printf("ReturnEvent:      %lu\t%u\t%p\n", *tid_ptr, *id_ptr,
    (void*)*addr_ptr);
        break;
      case ArgumentEventLabel:
        printf("ArgumentEvent:    %lu\t%p\n", *tid_ptr, (void*)*addr_ptr);
        break;
      case  MemsetEventLabel:
        printf("MemsetEvent:      %lu\t%u\t%p\t%lu\n", *tid_ptr, *id_ptr,
    (void*)*addr_ptr, *length_ptr);
        break;
      case  MemmoveEventLabel:
        printf("MemmoveEvent:     %lu\t%u\t%p\t%p\t%lu\n", *tid_ptr, *id_ptr,
    (void*)*addr_ptr, (void*)*addr2_ptr, *length_ptr);
        break;
    }
#endif
    // Collecting the arguments of a function call event
    if (event_label == ArgumentEventLabel) {
      args[*tid_ptr].insert(*addr_ptr);
      continue;
    }
    if (event_label == MemoryEventLabel && (*id_ptr == (uint32_t) - 1) && (*tid_ptr == 0) ) {
      SmallestBlock b;
      b.Type = SmallestBlock::DeclareBlock;
      b.Addr.push_back(*addr_ptr);
      b.Addr.push_back(*addr_ptr + *length_ptr);
#ifdef SLIMMER_PRINT_BLOCKS
      b.Print(Ins, BB2Ins);
#endif
      block_trace.push_back(b);
      continue;
    }

    if (event_label == BasicBlockEventLabel) {
      if (call_stack[*tid_ptr].empty()) {
        // This is the first basic block of a thread.
        is_first[*tid_ptr] = make_pair(2, 0);
        call_stack[*tid_ptr].push_back(StackInfo(*id_ptr, -1, 0));
      } else {
        StackInfo info = call_stack[*tid_ptr].back();
        if (info.CurIndex >= BB2Ins[info.BBID].size()) {
          // There is already a basic block executed by this function.
          is_first[*tid_ptr] = make_pair(0, 0);
          call_stack[*tid_ptr].back() = StackInfo(*id_ptr, info.BBID, 0);
        } else {
          // This is the starting basic block of a called function.
          is_first[*tid_ptr] =
              make_pair(1, BB2Ins[info.BBID][info.CurIndex - 1]);
          call_stack[*tid_ptr].push_back(StackInfo(*id_ptr, -1, 0));
        }
      }
    } else if (event_label == MemoryEventLabel) {
      if (*id_ptr == (uint32_t) - 1) { // A declare block
        SmallestBlock b;
        b.Type = SmallestBlock::DeclareBlock;
        b.Addr.push_back(*addr_ptr);
        b.Addr.push_back(*addr_ptr + *length_ptr);
#ifdef SLIMMER_PRINT_BLOCKS
        b.Print(Ins, BB2Ins);
#endif
        block_trace.push_back(b);
      } else { // A memory access block
        StackInfo &info = call_stack[*tid_ptr].back();
        uint32_t ins_id = BB2Ins[info.BBID][info.CurIndex++];
        assert((*id_ptr) == ins_id);

        SmallestBlock b(SmallestBlock::MemoryAccessBlock, *tid_ptr, info.BBID,
                        info.CurIndex - 1, info.CurIndex, is_first[*tid_ptr],
                        call_stack[*tid_ptr].back().LastBBID);
        b.Addr.push_back(*addr_ptr);
        b.Addr.push_back(*addr_ptr + *length_ptr);

#ifdef SLIMMER_PRINT_BLOCKS
        b.Print(Ins, BB2Ins);
#endif
        block_trace.push_back(b);
        is_first[*tid_ptr] = make_pair(0, 0);
      }
    } else if (event_label == ReturnEventLabel) {
      StackInfo &info = call_stack[*tid_ptr].back();
      uint32_t ins_id = BB2Ins[info.BBID][info.CurIndex++];
      assert((*id_ptr) == ins_id);

      SmallestBlock b(SmallestBlock::ExternalCallBlock, *tid_ptr, info.BBID,
                      info.CurIndex - 1, info.CurIndex, is_first[*tid_ptr],
                      call_stack[*tid_ptr].back().LastBBID);
      b.Addr.push_back(*addr_ptr);

      for (auto i : args[*tid_ptr])
        b.Addr.push_back(i);
      args[*tid_ptr].clear();

      if (impactful_fun_call.count(*addr_ptr) ||
          IsImpactfulFunction(Ins[ins_id].Fun)) {
        b.Type = SmallestBlock::ImpactfulCallBlock;
      }

      fun_counter[I(*tid_ptr, *addr_ptr)]++;
#ifdef SLIMMER_PRINT_BLOCKS
      b.Print(Ins, BB2Ins);
#endif
      block_trace.push_back(b);
      is_first[*tid_ptr] = make_pair(0, 0);
    } else if (event_label == MemsetEventLabel) {
      StackInfo &info = call_stack[*tid_ptr].back();
      uint32_t ins_id = BB2Ins[info.BBID][info.CurIndex++];
      assert((*id_ptr) == ins_id);

      SmallestBlock b(SmallestBlock::MemsetBlock, *tid_ptr, info.BBID,
                      info.CurIndex - 1, info.CurIndex, is_first[*tid_ptr],
                      call_stack[*tid_ptr].back().LastBBID);
      b.Addr.push_back(*addr_ptr);
      b.Addr.push_back(*addr_ptr + *length_ptr);

#ifdef SLIMMER_PRINT_BLOCKS
      b.Print(Ins, BB2Ins);
#endif
      block_trace.push_back(b);
      is_first[*tid_ptr] = make_pair(0, 0);
    } else if (event_label == MemmoveEventLabel) {
      StackInfo &info = call_stack[*tid_ptr].back();
      uint32_t ins_id = BB2Ins[info.BBID][info.CurIndex++];
      assert((*id_ptr) == ins_id);

      SmallestBlock b(SmallestBlock::MemmoveBlock, *tid_ptr, info.BBID,
                      info.CurIndex - 1, info.CurIndex, is_first[*tid_ptr],
                      call_stack[*tid_ptr].back().LastBBID);
      b.Addr.push_back(*addr_ptr);
      b.Addr.push_back(*addr_ptr + *length_ptr);
      b.Addr.push_back(*addr2_ptr);
      b.Addr.push_back(*addr2_ptr + *length_ptr);

#ifdef SLIMMER_PRINT_BLOCKS
      b.Print(Ins, BB2Ins);
#endif
      block_trace.push_back(b);
      is_first[*tid_ptr] = make_pair(0, 0);
    }

    while (!call_stack[*tid_ptr].empty()) {
      StackInfo &info = call_stack[*tid_ptr].back();
      uint32_t start_index = info.CurIndex, end_index;

      // Get a continuous part of a basic block
      // that will always be executed continuously.
      for (end_index = start_index; end_index < BB2Ins[info.BBID].size();
           ++end_index) {
        uint32_t ins_id = BB2Ins[info.BBID][end_index];
        if (!(Ins[ins_id].Type == InstInfo::NormalInst ||
              Ins[ins_id].Type == InstInfo::ReturnInst ||
              Ins[ins_id].Type == InstInfo::TerminatorInst ||
              Ins[ins_id].Type == InstInfo::PhiNode ||
              Ins[ins_id].Type == InstInfo::VarArg)) {
          break;
        }
      }
      // Intrinsic function calls are not treated as external calls
      if (end_index < BB2Ins[info.BBID].size() &&
          Ins[BB2Ins[info.BBID][end_index]].Type == InstInfo::CallInst &&
          Ins[BB2Ins[info.BBID][end_index]].Fun.substr(0, 5) != "llvm.")
        ++end_index;
      info.CurIndex = end_index;

      bool last_bb = false;
      if (info.CurIndex == BB2Ins[info.BBID].size()) {
        uint32_t last_ins_id = BB2Ins[info.BBID].back();
        if (Ins[last_ins_id].Type == InstInfo::ReturnInst) {
          // It is the last SmallestBlock of a function.
          last_bb = true;
        }
      }

      SmallestBlock b;
      if (end_index > start_index) {
        SmallestBlock b(SmallestBlock::NormalBlock, *tid_ptr, info.BBID,
                        start_index, end_index, is_first[*tid_ptr],
                        call_stack[*tid_ptr].back().LastBBID);
        if (last_bb) {
          call_stack[*tid_ptr].pop_back();

          if (call_stack[*tid_ptr].empty()) {
            b.IsLast = 2; // The last SmallestBlock of a thread.
          } else {
            b.IsLast = 1;
            StackInfo last_info = call_stack[*tid_ptr].back();
            assert(last_info.CurIndex < BB2Ins[last_info.BBID].size());
            if (Ins[BB2Ins[last_info.BBID][last_info.CurIndex - 1]].Type ==
                InstInfo::CallInst)
              b.Caller = BB2Ins[last_info.BBID][last_info.CurIndex - 1];
            else
              b.Caller = (uint32_t) - 1;
          }
        }
        is_first[*tid_ptr] = make_pair((uint8_t)0, (uint32_t)0);
#ifdef SLIMMER_PRINT_BLOCKS
        b.Print(Ins, BB2Ins);
#endif
        block_trace.push_back(b);
      }
      if (!last_bb)
        break;
    }
  }

  for (auto &i : call_stack) {
    auto tid = i.first;
    while (!i.second.empty()) {
      StackInfo &info = call_stack[tid].back();
      SmallestBlock b(SmallestBlock::NormalBlock, tid, info.BBID, info.CurIndex,
                      info.CurIndex, make_pair(0, 0),
                      call_stack[*tid_ptr].back().LastBBID);
      call_stack[tid].pop_back();

      if (call_stack[tid].empty()) {
        b.IsLast = 2; // The last SmallestBlock of a thread.
      } else {
        b.IsLast = 1;
        StackInfo last_info = call_stack[tid].back();
        assert(last_info.CurIndex < BB2Ins[last_info.BBID].size());
        if (Ins[BB2Ins[last_info.BBID][last_info.CurIndex - 1]].Type ==
            InstInfo::CallInst)
          b.Caller = BB2Ins[last_info.BBID][last_info.CurIndex - 1];
        else
          b.Caller = (uint32_t) - 1;
      }
#ifdef SLIMMER_PRINT_BLOCKS
      b.Print(Ins, BB2Ins);
#endif
      block_trace.push_back(b);
    }
  }
}
